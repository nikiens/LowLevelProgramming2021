\include{settings}

\begin{document}	% начало документа

% Титульная страница
\include{titlepage}

% Содержание
\include{ToC}

\section{Формулировка задания}
\begin{enumerate}
\item Разработать программу для EDSAC, реализующую определенную вариантом задания функциональность, и предполагающую загрузчик Initial Orders 1. Массив (массивы) данных и другие параметры (преобразуемое число, длина массива, параметр статистики и пр.) располагаются в памяти по фиксированным адресам.
\item Выделить определенную вариантом задания функциональность в замкнутую (closed) подпрограмму, разработать вызывающую ее тестовую программу. Использовать возможности загрузчика Initial Orders 2. Адрес обрабатываемого массива данных и другие параметры передавать через ячейки памяти с фиксированными адресами.
\end{enumerate}

\subsection{ Формулировка варианта задания}
Интегрирование табличной функции методом трапеций с «длинным» результатом.
\textit{Примечание: переполнение разрядной сетки предотвращается пользователем масштабированием параметра шага сетки.}

\[ \int_{a}^{b} f(x) \,dx = \sum_{i=0}^{n-1} \frac{f(x_i) + f(x_{i+1})}{2}(x_{i+1}-x_i) \]

\subsection{ Условные обозначения}
В работе используются следующие обозначения:
\begin{enumerate}
\item C(n) - значение n-й ячейки памяти
\item C(Acc) - значение в аккумуляторе
\item C(R) - значение в регистре умножения
\end{enumerate}

\section{Программа для Initial Orders 1}
\subsection{Входные и выходные данные}
Параметрами программы служат: C(101) - длина массивов \textit{коротких} чисел X и Y, C(102) и C(103) - адреса массивов X и Y соответственно. Элементы массива X хранятся в C(104) - C(111), а элементы массива Y с C(112) по C(119). 

Регулировка шага сетки предполагается модификацией значений X.

Результатом работы программы является значение определенного интеграла, полученное относительно X и Y, которое записывается в  C(120)

\subsection{Описание работы}
При старте программы формируется значение $n-1$ ($n$ - длина массива), использующееся в качестве счетчика итерации и записывается в рабочую ячейку C(1). Далее происходит инициализация адресных полей инструкций преобразования коротких чисел в длинные (необходимо для формирования длинного результата).
\makeatletter
\def\lst@PlaceNumber{\llap{\normalfont
                \lst@numberstyle{\the\lst@lineno}\kern\lst@numbersep}}
\makeatother

\lstinputlisting[
	label=code:hello_mod,
	linerange={1-29},
	caption={Фрагмент IO1.txt},
]{IO1.txt}
\parindent=1cm

Рабочий цикл программы можно разделить на три части: формирование длинных чисел, вычисление слагаемого по формуле и модификация адресных полей.

Формирование длинных чисел для $x_{i+1}$, $x_i$, $y_{i+1}$ и $y_i$ происходит путем загрузки соответствующих значений в аккумулятор, домножения на C(R) = 1, предварительно загруженную из C(100). После этого происходит коррекция полученных результатов путем сдвига на 2 разряда право. Результаты записываются в рабочие ячейки C(2), C(4), C(6) и C(8) для $x_{i+1}$, $x_i$, $y_{i+1}$ и $y_i$ соответственно.
\newline
\newline
\lstinputlisting[
	label=code:hello_mod,
	linerange={30-54},
	caption={Фрагмент IO1.txt},
]{IO1.txt}
\parindent=1cm

При вычислении слагаемого сначала вычисляется значение шага $(x_{i+1} - x_i)$. Результат записывается в рабочую ячейку C(10)
и загружается в C(R). Далее вычисляется значение $f(x_{i+1}) + f(x_i)$, результат записывается в рабочую ячейку C(12). Затем происходит умножение C(12) на C(R) ($f(x_{i+1}) + f(x_i) \cdot (x_{i+1} - x_i)$), после этого производится коррекция умножения сдвигом числа в аккумуляторе влево, при этом деление на 2 здесь уже учтено (т.к деление на 2 осществляется сдвигом результата на 1 разряд вправо) для корректной записи числа в выходную ячейку. 

Полученный результат суммируется с предыдущим из C(120) и записывается туда же.

\lstinputlisting[
	label=code:hello_mod,
	linerange={55-74},
	caption={Фрагмент IO1.txt},
]{IO1.txt}
\parindent=1cm

Модификация адресных полей происходит путем прибавления единицы (C(100)) к адресу предыдущего элемента в инструкциях преобразования коротких чисел в длинные(C(57), C(60), C(63), C(66)) для перехода к следующим элементам массива. Цикл повторяется, пока не обнулится счетчик.

\lstinputlisting[
	label=code:hello_mod,
	linerange={75-96},
	caption={Фрагмент IO1.txt},
]{IO1.txt}
\parindent=1cm

Константы и входные данные

\lstinputlisting[
	label=code:hello_mod,
	linerange={97-123},
	caption={Фрагмент IO1.txt},
]{IO1.txt}
\parindent=1cm

\section{Программа для Initial Orders 2}
Программа для IO2 основана на программе для IO1. Функциональность варианта задания выделена в замкнутую подпрограмму, выходное значение записывается в C(200). Длина массивов хранится в C(10), адреса массивов X и Y в C(11) и C(12) соответственно. Элементы массивов X и Y хранятся в C(13) - C(20) и C(21) - C(28) соответственно.

«Каркас» замкнутой подпрограммы состоит из типовых директив, адресованных загрузчику Initial Orders 2, а также «пролога» (prologue) и «эпилога» (epilogue) – инструкций, исполняемых соответственно сразу после вызова и непосредственно перед возвратом из подпрограммы.

\lstinputlisting[
	label=code:hello,
	caption={IO2.txt},% для печати символ '_' требует выходной символ '\'
]{IO2.txt}
\parindent=1cm % командна \lstinputlisting сбивает параментры отступа


\section{Выводы}
В ходе работы были разработаны программы для загрузчиков IO1 и IO2 EDSAC. ОСновной проблемой при работе с IO1 является абсолютная адресация, из-за которой возникает необходимость пересчитывать адреса при любом изменении программы. Данный недостаток был исправлен в IO2 введением относительной адресации.
\end{document}
